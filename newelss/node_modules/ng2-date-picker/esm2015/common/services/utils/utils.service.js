/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ECalendarValue } from '../../types/calendar-value-enum';
import { Injectable } from '@angular/core';
import * as momentNs from 'moment';
/** @type {?} */
const moment = momentNs;
/**
 * @record
 */
export function DateLimits() { }
if (false) {
    /** @type {?|undefined} */
    DateLimits.prototype.minDate;
    /** @type {?|undefined} */
    DateLimits.prototype.maxDate;
    /** @type {?|undefined} */
    DateLimits.prototype.minTime;
    /** @type {?|undefined} */
    DateLimits.prototype.maxTime;
}
export class UtilsService {
    /**
     * @param {?} func
     * @param {?} wait
     * @return {?}
     */
    static debounce(func, wait) {
        /** @type {?} */
        let timeout;
        return function () {
            /** @type {?} */
            const context = this;
            /** @type {?} */
            const args = arguments;
            timeout = clearTimeout(timeout);
            setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    ;
    /**
     * @param {?} size
     * @return {?}
     */
    createArray(size) {
        return new Array(size).fill(1);
    }
    /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    convertToMoment(date, format) {
        if (!date) {
            return null;
        }
        else if (typeof date === 'string') {
            return moment(date, format);
        }
        else {
            return date.clone();
        }
    }
    /**
     * @param {?} date
     * @param {?} format
     * @return {?}
     */
    isDateValid(date, format) {
        if (date === '') {
            return true;
        }
        return moment(date, format, true).isValid();
    }
    // todo:: add unit test
    /**
     * @param {?} current
     * @param {?} selected
     * @param {?} allowMultiSelect
     * @param {?} minDate
     * @return {?}
     */
    getDefaultDisplayDate(current, selected, allowMultiSelect, minDate) {
        if (current) {
            return current.clone();
        }
        else if (minDate && minDate.isAfter(moment())) {
            return minDate.clone();
        }
        else if (allowMultiSelect) {
            if (selected && selected[selected.length]) {
                return selected[selected.length].clone();
            }
        }
        else if (selected && selected[0]) {
            return selected[0].clone();
        }
        return moment();
    }
    // todo:: add unit test
    /**
     * @param {?} value
     * @param {?} allowMultiSelect
     * @return {?}
     */
    getInputType(value, allowMultiSelect) {
        if (Array.isArray(value)) {
            if (!value.length) {
                return ECalendarValue.MomentArr;
            }
            else if (typeof value[0] === 'string') {
                return ECalendarValue.StringArr;
            }
            else if (moment.isMoment(value[0])) {
                return ECalendarValue.MomentArr;
            }
        }
        else {
            if (typeof value === 'string') {
                return ECalendarValue.String;
            }
            else if (moment.isMoment(value)) {
                return ECalendarValue.Moment;
            }
        }
        return allowMultiSelect ? ECalendarValue.MomentArr : ECalendarValue.Moment;
    }
    // todo:: add unit test
    /**
     * @param {?} value
     * @param {?} format
     * @param {?} allowMultiSelect
     * @return {?}
     */
    convertToMomentArray(value, format, allowMultiSelect) {
        switch (this.getInputType(value, allowMultiSelect)) {
            case (ECalendarValue.String):
                return value ? [moment((/** @type {?} */ (value)), format, true)] : [];
            case (ECalendarValue.StringArr):
                return ((/** @type {?} */ (value))).map(v => v ? moment(v, format, true) : null).filter(Boolean);
            case (ECalendarValue.Moment):
                return value ? [((/** @type {?} */ (value))).clone()] : [];
            case (ECalendarValue.MomentArr):
                return ((/** @type {?} */ (value)) || []).map(v => v.clone());
            default:
                return [];
        }
    }
    // todo:: add unit test
    /**
     * @param {?} format
     * @param {?} value
     * @param {?} convertTo
     * @return {?}
     */
    convertFromMomentArray(format, value, convertTo) {
        switch (convertTo) {
            case (ECalendarValue.String):
                return value[0] && value[0].format(format);
            case (ECalendarValue.StringArr):
                return value.filter(Boolean).map(v => v.format(format));
            case (ECalendarValue.Moment):
                return value[0] ? value[0].clone() : value[0];
            case (ECalendarValue.MomentArr):
                return value ? value.map(v => v.clone()) : value;
            default:
                return value;
        }
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    convertToString(value, format) {
        /** @type {?} */
        let tmpVal;
        if (typeof value === 'string') {
            tmpVal = [value];
        }
        else if (Array.isArray(value)) {
            if (value.length) {
                tmpVal = ((/** @type {?} */ (value))).map((v) => {
                    return this.convertToMoment(v, format).format(format);
                });
            }
            else {
                tmpVal = (/** @type {?} */ (value));
            }
        }
        else if (moment.isMoment(value)) {
            tmpVal = [value.format(format)];
        }
        else {
            return '';
        }
        return tmpVal.filter(Boolean).join(' | ');
    }
    // todo:: add unit test
    /**
     * @template T
     * @param {?} obj
     * @return {?}
     */
    clearUndefined(obj) {
        if (!obj) {
            return obj;
        }
        Object.keys(obj).forEach((key) => (obj[key] === undefined) && delete obj[key]);
        return obj;
    }
    /**
     * @param {?} isMultiple
     * @param {?} currentlySelected
     * @param {?} date
     * @param {?=} granularity
     * @return {?}
     */
    updateSelected(isMultiple, currentlySelected, date, granularity = 'day') {
        if (isMultiple) {
            return !date.selected
                ? currentlySelected.concat([date.date])
                : currentlySelected.filter(d => !d.isSame(date.date, granularity));
        }
        else {
            return !date.selected ? [date.date] : [];
        }
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    closestParent(element, selector) {
        if (!element) {
            return undefined;
        }
        /** @type {?} */
        const match = (/** @type {?} */ (element.querySelector(selector)));
        return match || this.closestParent(element.parentElement, selector);
    }
    /**
     * @param {?} m
     * @return {?}
     */
    onlyTime(m) {
        return m && moment.isMoment(m) && moment(m.format('HH:mm:ss'), 'HH:mm:ss');
    }
    /**
     * @param {?} calendarType
     * @return {?}
     */
    granularityFromType(calendarType) {
        switch (calendarType) {
            case 'time':
                return 'second';
            case 'daytime':
                return 'second';
            default:
                return calendarType;
        }
    }
    /**
     * @param {?} __0
     * @param {?} format
     * @param {?} calendarType
     * @return {?}
     */
    createValidator({ minDate, maxDate, minTime, maxTime }, format, calendarType) {
        /** @type {?} */
        let isValid;
        /** @type {?} */
        let value;
        /** @type {?} */
        const validators = [];
        /** @type {?} */
        const granularity = this.granularityFromType(calendarType);
        if (minDate) {
            /** @type {?} */
            const md = this.convertToMoment(minDate, format);
            validators.push({
                key: 'minDate',
                isValid: () => {
                    /** @type {?} */
                    const _isValid = value.every(val => val.isSameOrAfter(md, granularity));
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        if (maxDate) {
            /** @type {?} */
            const md = this.convertToMoment(maxDate, format);
            validators.push({
                key: 'maxDate',
                isValid: () => {
                    /** @type {?} */
                    const _isValid = value.every(val => val.isSameOrBefore(md, granularity));
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        if (minTime) {
            /** @type {?} */
            const md = this.onlyTime(this.convertToMoment(minTime, format));
            validators.push({
                key: 'minTime',
                isValid: () => {
                    /** @type {?} */
                    const _isValid = value.every(val => this.onlyTime(val).isSameOrAfter(md));
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        if (maxTime) {
            /** @type {?} */
            const md = this.onlyTime(this.convertToMoment(maxTime, format));
            validators.push({
                key: 'maxTime',
                isValid: () => {
                    /** @type {?} */
                    const _isValid = value.every(val => this.onlyTime(val).isSameOrBefore(md));
                    isValid = isValid ? _isValid : false;
                    return _isValid;
                }
            });
        }
        return (inputVal) => {
            isValid = true;
            value = this.convertToMomentArray(inputVal, format, true).filter(Boolean);
            if (!value.every(val => val.isValid())) {
                return {
                    format: {
                        given: inputVal
                    }
                };
            }
            /** @type {?} */
            const errors = validators.reduce((map, err) => {
                if (!err.isValid()) {
                    map[err.key] = {
                        given: value
                    };
                }
                return map;
            }, {});
            return !isValid ? errors : null;
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    datesStringToStringArray(value) {
        return (value || '').split('|').map(m => m.trim()).filter(Boolean);
    }
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    getValidMomentArray(value, format) {
        return this.datesStringToStringArray(value)
            .filter(d => this.isDateValid(d, format))
            .map(d => moment(d, format));
    }
    /**
     * @param {?} showGoToCurrent
     * @param {?} mode
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    shouldShowCurrent(showGoToCurrent, mode, min, max) {
        return showGoToCurrent &&
            mode !== 'time' &&
            this.isDateInRange(moment(), min, max);
    }
    /**
     * @param {?} date
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    isDateInRange(date, from, to) {
        return date.isBetween(from, to, 'day', '[]');
    }
    /**
     * @param {?} obj
     * @param {?} format
     * @param {?} props
     * @return {?}
     */
    convertPropsToMoment(obj, format, props) {
        props.forEach((prop) => {
            if (obj.hasOwnProperty(prop)) {
                obj[prop] = this.convertToMoment(obj[prop], format);
            }
        });
    }
    /**
     * @template T
     * @param {?} prevConf
     * @param {?} currentConf
     * @return {?}
     */
    shouldResetCurrentView(prevConf, currentConf) {
        if (prevConf && currentConf) {
            if (!prevConf.min && currentConf.min) {
                return true;
            }
            else if (prevConf.min && currentConf.min && !prevConf.min.isSame(currentConf.min, 'd')) {
                return true;
            }
            else if (!prevConf.max && currentConf.max) {
                return true;
            }
            else if (prevConf.max && currentConf.max && !prevConf.max.isSame(currentConf.max, 'd')) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    getNativeElement(elem) {
        if (!elem) {
            return null;
        }
        else if (typeof elem === 'string') {
            return (/** @type {?} */ (document.querySelector(elem)));
        }
        else {
            return elem;
        }
    }
}
UtilsService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nMi1kYXRlLXBpY2tlci8iLCJzb3VyY2VzIjpbImNvbW1vbi9zZXJ2aWNlcy91dGlscy91dGlscy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0saUNBQWlDLENBQUM7QUFFL0QsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEtBQUssUUFBUSxNQUFNLFFBQVEsQ0FBQzs7TUFRN0IsTUFBTSxHQUFHLFFBQVE7Ozs7QUFFdkIsZ0NBS0M7OztJQUpDLDZCQUE4Qjs7SUFDOUIsNkJBQThCOztJQUM5Qiw2QkFBOEI7O0lBQzlCLDZCQUE4Qjs7QUFJaEMsTUFBTSxPQUFPLFlBQVk7Ozs7OztJQUN2QixNQUFNLENBQUMsUUFBUSxDQUFDLElBQWMsRUFBRSxJQUFZOztZQUN0QyxPQUFPO1FBQ1gsT0FBTzs7a0JBQ0MsT0FBTyxHQUFHLElBQUk7O2tCQUFFLElBQUksR0FBRyxTQUFTO1lBQ3RDLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDaEMsVUFBVSxDQUFDLEdBQUcsRUFBRTtnQkFDZCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM1QixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDWCxDQUFDLENBQUM7SUFDSixDQUFDO0lBQUEsQ0FBQzs7Ozs7SUFFRixXQUFXLENBQUMsSUFBWTtRQUN0QixPQUFPLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqQyxDQUFDOzs7Ozs7SUFFRCxlQUFlLENBQUMsSUFBeUIsRUFBRSxNQUFjO1FBQ3ZELElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLElBQUksQ0FBQztTQUNiO2FBQU0sSUFBSSxPQUFPLElBQUksS0FBSyxR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LENBQUMsSUFBSSxDQUFDLEVBQUEsQ0FBQztTQUNsRDthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtJQUNILENBQUM7OztZQTlURixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtFQ2FsZW5kYXJWYWx1ZX0gZnJvbSAnLi4vLi4vdHlwZXMvY2FsZW5kYXItdmFsdWUtZW51bSc7XG5pbXBvcnQge1NpbmdsZUNhbGVuZGFyVmFsdWV9IGZyb20gJy4uLy4uL3R5cGVzL3NpbmdsZS1jYWxlbmRhci12YWx1ZSc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgbW9tZW50TnMgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7TW9tZW50LCB1bml0T2ZUaW1lfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtDYWxlbmRhclZhbHVlfSBmcm9tICcuLi8uLi90eXBlcy9jYWxlbmRhci12YWx1ZSc7XG5pbXBvcnQge0lEYXRlfSBmcm9tICcuLi8uLi9tb2RlbHMvZGF0ZS5tb2RlbCc7XG5pbXBvcnQge0NhbGVuZGFyTW9kZX0gZnJvbSAnLi4vLi4vdHlwZXMvY2FsZW5kYXItbW9kZSc7XG5pbXBvcnQge0RhdGVWYWxpZGF0b3J9IGZyb20gJy4uLy4uL3R5cGVzL3ZhbGlkYXRvci50eXBlJztcbmltcG9ydCB7SUNhbGVuZGFySW50ZXJuYWx9IGZyb20gJy4uLy4uL21vZGVscy9jYWxlbmRhci5tb2RlbCc7XG5cbmNvbnN0IG1vbWVudCA9IG1vbWVudE5zO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVMaW1pdHMge1xuICBtaW5EYXRlPzogU2luZ2xlQ2FsZW5kYXJWYWx1ZTtcbiAgbWF4RGF0ZT86IFNpbmdsZUNhbGVuZGFyVmFsdWU7XG4gIG1pblRpbWU/OiBTaW5nbGVDYWxlbmRhclZhbHVlO1xuICBtYXhUaW1lPzogU2luZ2xlQ2FsZW5kYXJWYWx1ZTtcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFV0aWxzU2VydmljZSB7XG4gIHN0YXRpYyBkZWJvdW5jZShmdW5jOiBGdW5jdGlvbiwgd2FpdDogbnVtYmVyKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSwgd2FpdCk7XG4gICAgfTtcbiAgfTtcblxuICBjcmVhdGVBcnJheShzaXplOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShzaXplKS5maWxsKDEpO1xuICB9XG5cbiAgY29udmVydFRvTW9tZW50KGRhdGU6IFNpbmdsZUNhbGVuZGFyVmFsdWUsIGZvcm1hdDogc3RyaW5nKTogTW9tZW50IHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbW9tZW50KGRhdGUsIGZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRlLmNsb25lKCk7XG4gICAgfVxuICB9XG5cbiAgaXNEYXRlVmFsaWQoZGF0ZTogc3RyaW5nLCBmb3JtYXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmIChkYXRlID09PSAnJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbWVudChkYXRlLCBmb3JtYXQsIHRydWUpLmlzVmFsaWQoKTtcbiAgfVxuXG4gIC8vIHRvZG86OiBhZGQgdW5pdCB0ZXN0XG4gIGdldERlZmF1bHREaXNwbGF5RGF0ZShjdXJyZW50OiBNb21lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogTW9tZW50W10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd011bHRpU2VsZWN0OiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGF0ZTogTW9tZW50KTogTW9tZW50IHtcbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKG1pbkRhdGUgJiYgbWluRGF0ZS5pc0FmdGVyKG1vbWVudCgpKSkge1xuICAgICAgcmV0dXJuIG1pbkRhdGUuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGFsbG93TXVsdGlTZWxlY3QpIHtcbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZFtzZWxlY3RlZC5sZW5ndGhdKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFtzZWxlY3RlZC5sZW5ndGhdLmNsb25lKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZFswXSkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkWzBdLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbWVudCgpO1xuICB9XG5cbiAgLy8gdG9kbzo6IGFkZCB1bml0IHRlc3RcbiAgZ2V0SW5wdXRUeXBlKHZhbHVlOiBDYWxlbmRhclZhbHVlLCBhbGxvd011bHRpU2VsZWN0OiBib29sZWFuKTogRUNhbGVuZGFyVmFsdWUge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIEVDYWxlbmRhclZhbHVlLk1vbWVudEFycjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gRUNhbGVuZGFyVmFsdWUuU3RyaW5nQXJyO1xuICAgICAgfSBlbHNlIGlmIChtb21lbnQuaXNNb21lbnQodmFsdWVbMF0pKSB7XG4gICAgICAgIHJldHVybiBFQ2FsZW5kYXJWYWx1ZS5Nb21lbnRBcnI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBFQ2FsZW5kYXJWYWx1ZS5TdHJpbmc7XG4gICAgICB9IGVsc2UgaWYgKG1vbWVudC5pc01vbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEVDYWxlbmRhclZhbHVlLk1vbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWxsb3dNdWx0aVNlbGVjdCA/IEVDYWxlbmRhclZhbHVlLk1vbWVudEFyciA6IEVDYWxlbmRhclZhbHVlLk1vbWVudDtcbiAgfVxuXG4gIC8vIHRvZG86OiBhZGQgdW5pdCB0ZXN0XG4gIGNvbnZlcnRUb01vbWVudEFycmF5KHZhbHVlOiBDYWxlbmRhclZhbHVlLCBmb3JtYXQ6IHN0cmluZywgYWxsb3dNdWx0aVNlbGVjdDogYm9vbGVhbik6IE1vbWVudFtdIHtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0SW5wdXRUeXBlKHZhbHVlLCBhbGxvd011bHRpU2VsZWN0KSkge1xuICAgICAgY2FzZSAoRUNhbGVuZGFyVmFsdWUuU3RyaW5nKTpcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gW21vbWVudCg8c3RyaW5nPnZhbHVlLCBmb3JtYXQsIHRydWUpXSA6IFtdO1xuICAgICAgY2FzZSAoRUNhbGVuZGFyVmFsdWUuU3RyaW5nQXJyKTpcbiAgICAgICAgcmV0dXJuICg8c3RyaW5nW10+dmFsdWUpLm1hcCh2ID0+IHYgPyBtb21lbnQodiwgZm9ybWF0LCB0cnVlKSA6IG51bGwpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGNhc2UgKEVDYWxlbmRhclZhbHVlLk1vbWVudCk6XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFsoPE1vbWVudD52YWx1ZSkuY2xvbmUoKV0gOiBbXTtcbiAgICAgIGNhc2UgKEVDYWxlbmRhclZhbHVlLk1vbWVudEFycik6XG4gICAgICAgIHJldHVybiAoPE1vbWVudFtdPnZhbHVlIHx8IFtdKS5tYXAodiA9PiB2LmNsb25lKCkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRvZG86OiBhZGQgdW5pdCB0ZXN0XG4gIGNvbnZlcnRGcm9tTW9tZW50QXJyYXkoZm9ybWF0OiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE1vbWVudFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRUbzogRUNhbGVuZGFyVmFsdWUpOiBDYWxlbmRhclZhbHVlIHtcbiAgICBzd2l0Y2ggKGNvbnZlcnRUbykge1xuICAgICAgY2FzZSAoRUNhbGVuZGFyVmFsdWUuU3RyaW5nKTpcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdICYmIHZhbHVlWzBdLmZvcm1hdChmb3JtYXQpO1xuICAgICAgY2FzZSAoRUNhbGVuZGFyVmFsdWUuU3RyaW5nQXJyKTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLmZpbHRlcihCb29sZWFuKS5tYXAodiA9PiB2LmZvcm1hdChmb3JtYXQpKTtcbiAgICAgIGNhc2UgKEVDYWxlbmRhclZhbHVlLk1vbWVudCk6XG4gICAgICAgIHJldHVybiB2YWx1ZVswXSA/IHZhbHVlWzBdLmNsb25lKCkgOiB2YWx1ZVswXTtcbiAgICAgIGNhc2UgKEVDYWxlbmRhclZhbHVlLk1vbWVudEFycik6XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLm1hcCh2ID0+IHYuY2xvbmUoKSkgOiB2YWx1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBjb252ZXJ0VG9TdHJpbmcodmFsdWU6IENhbGVuZGFyVmFsdWUsIGZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgdG1wVmFsOiBzdHJpbmdbXTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0bXBWYWwgPSBbdmFsdWVdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdG1wVmFsID0gKDxTaW5nbGVDYWxlbmRhclZhbHVlW10+dmFsdWUpLm1hcCgodikgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUb01vbWVudCh2LCBmb3JtYXQpLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcFZhbCA9IDxzdHJpbmdbXT52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1vbWVudC5pc01vbWVudCh2YWx1ZSkpIHtcbiAgICAgIHRtcFZhbCA9IFt2YWx1ZS5mb3JtYXQoZm9ybWF0KV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdG1wVmFsLmZpbHRlcihCb29sZWFuKS5qb2luKCcgfCAnKTtcbiAgfVxuXG4gIC8vIHRvZG86OiBhZGQgdW5pdCB0ZXN0XG4gIGNsZWFyVW5kZWZpbmVkPFQ+KG9iajogVCk6IFQge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkgJiYgZGVsZXRlIG9ialtrZXldKTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdXBkYXRlU2VsZWN0ZWQoaXNNdWx0aXBsZTogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgY3VycmVudGx5U2VsZWN0ZWQ6IE1vbWVudFtdLFxuICAgICAgICAgICAgICAgICBkYXRlOiBJRGF0ZSxcbiAgICAgICAgICAgICAgICAgZ3JhbnVsYXJpdHk6IHVuaXRPZlRpbWUuQmFzZSA9ICdkYXknKTogTW9tZW50W10ge1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICByZXR1cm4gIWRhdGUuc2VsZWN0ZWRcbiAgICAgICAgPyBjdXJyZW50bHlTZWxlY3RlZC5jb25jYXQoW2RhdGUuZGF0ZV0pXG4gICAgICAgIDogY3VycmVudGx5U2VsZWN0ZWQuZmlsdGVyKGQgPT4gIWQuaXNTYW1lKGRhdGUuZGF0ZSwgZ3JhbnVsYXJpdHkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICFkYXRlLnNlbGVjdGVkID8gW2RhdGUuZGF0ZV0gOiBbXTtcbiAgICB9XG4gIH1cblxuICBjbG9zZXN0UGFyZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcjogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSA8SFRNTEVsZW1lbnQ+ZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gbWF0Y2ggfHwgdGhpcy5jbG9zZXN0UGFyZW50KGVsZW1lbnQucGFyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xuICB9XG5cbiAgb25seVRpbWUobTogTW9tZW50KTogTW9tZW50IHtcbiAgICByZXR1cm4gbSAmJiBtb21lbnQuaXNNb21lbnQobSkgJiYgbW9tZW50KG0uZm9ybWF0KCdISDptbTpzcycpLCAnSEg6bW06c3MnKTtcbiAgfVxuXG4gIGdyYW51bGFyaXR5RnJvbVR5cGUoY2FsZW5kYXJUeXBlOiBDYWxlbmRhck1vZGUpOiB1bml0T2ZUaW1lLkJhc2Uge1xuICAgIHN3aXRjaCAoY2FsZW5kYXJUeXBlKSB7XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgcmV0dXJuICdzZWNvbmQnO1xuICAgICAgY2FzZSAnZGF5dGltZSc6XG4gICAgICAgIHJldHVybiAnc2Vjb25kJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjYWxlbmRhclR5cGU7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVmFsaWRhdG9yKHttaW5EYXRlLCBtYXhEYXRlLCBtaW5UaW1lLCBtYXhUaW1lfTogRGF0ZUxpbWl0cyxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgY2FsZW5kYXJUeXBlOiBDYWxlbmRhck1vZGUpOiBEYXRlVmFsaWRhdG9yIHtcbiAgICBsZXQgaXNWYWxpZDogYm9vbGVhbjtcbiAgICBsZXQgdmFsdWU6IE1vbWVudFtdO1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICBjb25zdCBncmFudWxhcml0eSA9IHRoaXMuZ3JhbnVsYXJpdHlGcm9tVHlwZShjYWxlbmRhclR5cGUpO1xuXG4gICAgaWYgKG1pbkRhdGUpIHtcbiAgICAgIGNvbnN0IG1kID0gdGhpcy5jb252ZXJ0VG9Nb21lbnQobWluRGF0ZSwgZm9ybWF0KTtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh7XG4gICAgICAgIGtleTogJ21pbkRhdGUnLFxuICAgICAgICBpc1ZhbGlkOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgX2lzVmFsaWQgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gdmFsLmlzU2FtZU9yQWZ0ZXIobWQsIGdyYW51bGFyaXR5KSk7XG4gICAgICAgICAgaXNWYWxpZCA9IGlzVmFsaWQgPyBfaXNWYWxpZCA6IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBfaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1heERhdGUpIHtcbiAgICAgIGNvbnN0IG1kID0gdGhpcy5jb252ZXJ0VG9Nb21lbnQobWF4RGF0ZSwgZm9ybWF0KTtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh7XG4gICAgICAgIGtleTogJ21heERhdGUnLFxuICAgICAgICBpc1ZhbGlkOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgX2lzVmFsaWQgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gdmFsLmlzU2FtZU9yQmVmb3JlKG1kLCBncmFudWxhcml0eSkpO1xuICAgICAgICAgIGlzVmFsaWQgPSBpc1ZhbGlkID8gX2lzVmFsaWQgOiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gX2lzVmFsaWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtaW5UaW1lKSB7XG4gICAgICBjb25zdCBtZCA9IHRoaXMub25seVRpbWUodGhpcy5jb252ZXJ0VG9Nb21lbnQobWluVGltZSwgZm9ybWF0KSk7XG4gICAgICB2YWxpZGF0b3JzLnB1c2goe1xuICAgICAgICBrZXk6ICdtaW5UaW1lJyxcbiAgICAgICAgaXNWYWxpZDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IF9pc1ZhbGlkID0gdmFsdWUuZXZlcnkodmFsID0+IHRoaXMub25seVRpbWUodmFsKS5pc1NhbWVPckFmdGVyKG1kKSk7XG4gICAgICAgICAgaXNWYWxpZCA9IGlzVmFsaWQgPyBfaXNWYWxpZCA6IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBfaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1heFRpbWUpIHtcbiAgICAgIGNvbnN0IG1kID0gdGhpcy5vbmx5VGltZSh0aGlzLmNvbnZlcnRUb01vbWVudChtYXhUaW1lLCBmb3JtYXQpKTtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh7XG4gICAgICAgIGtleTogJ21heFRpbWUnLFxuICAgICAgICBpc1ZhbGlkOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgX2lzVmFsaWQgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gdGhpcy5vbmx5VGltZSh2YWwpLmlzU2FtZU9yQmVmb3JlKG1kKSk7XG4gICAgICAgICAgaXNWYWxpZCA9IGlzVmFsaWQgPyBfaXNWYWxpZCA6IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBfaXNWYWxpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChpbnB1dFZhbDogQ2FsZW5kYXJWYWx1ZSkgPT4ge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG5cbiAgICAgIHZhbHVlID0gdGhpcy5jb252ZXJ0VG9Nb21lbnRBcnJheShpbnB1dFZhbCwgZm9ybWF0LCB0cnVlKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICAgIGlmICghdmFsdWUuZXZlcnkodmFsID0+IHZhbC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICBnaXZlbjogaW5wdXRWYWxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9ycyA9IHZhbGlkYXRvcnMucmVkdWNlKChtYXAsIGVycikgPT4ge1xuICAgICAgICBpZiAoIWVyci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICBtYXBbZXJyLmtleV0gPSB7XG4gICAgICAgICAgICBnaXZlbjogdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgcmV0dXJuICFpc1ZhbGlkID8gZXJyb3JzIDogbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZGF0ZXNTdHJpbmdUb1N0cmluZ0FycmF5KHZhbHVlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuICh2YWx1ZSB8fCAnJykuc3BsaXQoJ3wnKS5tYXAobSA9PiBtLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG5cbiAgZ2V0VmFsaWRNb21lbnRBcnJheSh2YWx1ZTogc3RyaW5nLCBmb3JtYXQ6IHN0cmluZyk6IE1vbWVudFtdIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlc1N0cmluZ1RvU3RyaW5nQXJyYXkodmFsdWUpXG4gICAgICAuZmlsdGVyKGQgPT4gdGhpcy5pc0RhdGVWYWxpZChkLCBmb3JtYXQpKVxuICAgICAgLm1hcChkID0+IG1vbWVudChkLCBmb3JtYXQpKTtcbiAgfVxuXG4gIHNob3VsZFNob3dDdXJyZW50KHNob3dHb1RvQ3VycmVudDogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ2FsZW5kYXJNb2RlLFxuICAgICAgICAgICAgICAgICAgICBtaW46IE1vbWVudCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBNb21lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc2hvd0dvVG9DdXJyZW50ICYmXG4gICAgICBtb2RlICE9PSAndGltZScgJiZcbiAgICAgIHRoaXMuaXNEYXRlSW5SYW5nZShtb21lbnQoKSwgbWluLCBtYXgpO1xuICB9XG5cbiAgaXNEYXRlSW5SYW5nZShkYXRlOiBNb21lbnQsIGZyb206IE1vbWVudCwgdG86IE1vbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXRlLmlzQmV0d2Vlbihmcm9tLCB0bywgJ2RheScsICdbXScpO1xuICB9XG5cbiAgY29udmVydFByb3BzVG9Nb21lbnQob2JqOiB7W2tleTogc3RyaW5nXTogYW55fSwgZm9ybWF0OiBzdHJpbmcsIHByb3BzOiBzdHJpbmdbXSkge1xuICAgIHByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gdGhpcy5jb252ZXJ0VG9Nb21lbnQob2JqW3Byb3BdLCBmb3JtYXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2hvdWxkUmVzZXRDdXJyZW50VmlldzxUIGV4dGVuZHMgSUNhbGVuZGFySW50ZXJuYWw+KHByZXZDb25mOiBULCBjdXJyZW50Q29uZjogVCk6IGJvb2xlYW4ge1xuICAgIGlmIChwcmV2Q29uZiAmJiBjdXJyZW50Q29uZikge1xuICAgICAgaWYgKCFwcmV2Q29uZi5taW4gJiYgY3VycmVudENvbmYubWluKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwcmV2Q29uZi5taW4gJiYgY3VycmVudENvbmYubWluICYmICFwcmV2Q29uZi5taW4uaXNTYW1lKGN1cnJlbnRDb25mLm1pbiwgJ2QnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXByZXZDb25mLm1heCAmJiBjdXJyZW50Q29uZi5tYXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByZXZDb25mLm1heCAmJiBjdXJyZW50Q29uZi5tYXggJiYgIXByZXZDb25mLm1heC5pc1NhbWUoY3VycmVudENvbmYubWF4LCAnZCcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0TmF0aXZlRWxlbWVudChlbGVtOiBIVE1MRWxlbWVudCB8IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgfVxufVxuIl19